{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"A little less unfinished TFTP bootloader for Arduino Ethernet or Arduino Uno with Ethernet Shield","google":"","body":"Ariadne Bootloader for Arduino and WizNet W5100\r\n===============================================\r\n\r\nBootloader for Arduino with Ethernet\r\n------------------------------------\r\nThis is a beta stage bootloader for Arduino Ethernet board and the regular\r\nArduino with Ethernet Shield. It is based on previous unfinished work by the Arduino\r\ndevelopers. The bootloader implements a TFTP server on the Arduino board and flashing works\r\nusing any regular TFTP client.\r\n\r\n\r\nThe Files and Folders in this Repository\r\n----------------------------------------\r\nThe structure of this repository is made to follow the standarts of the Arduino IDE.\r\nThis way you can simply copy the folders in your sketchbook and be ready\r\n\r\n* hardware: This is where the bootloader resides.\r\n* java-client: Demo client for the bootloader. Inherited by the initial project. Untested and probably non-functional\r\n* libraries: Helper libraries to support functions of the bootloader\r\n* utilities: Various stuff used for development and debugging\r\n\r\n\r\nDownloading and Installing Files\r\n--------------------------------\r\nFirst of all, you need to clone or download the repository. To clone the repository\r\nyou need to have git installed, then you can run\r\n```git clone https://github.com/codebendercc/Ariadne-Bootloader.git```\r\nin a directory.\r\nThis way you can later update your local repository by running\r\n```git pull```\r\ninside the **Ariadne-Bootloader** directory.\r\n\r\nIn case you want to avoid this hassle, you can use the **ZIP** button at the top of the page\r\nto download the latest snapshot of the repository in a zip archive and extract it.\r\n\r\nAfter that you have to copy the **hardware** and **libraries** folders inside your sketchbook folder.\r\nTake extra care during coping not to overwrite any other files. Restart the Arduino IDE to load\r\nthe new boards and libraries.\r\n\r\n\r\nInstalling the Bootloader\r\n-------------------------\r\nTo burn the bootloader, you will need an [AVR-ISP](http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2726)\r\n(in-system programmer), [USBtinyISP](http://www.ladyada.net/make/usbtinyisp/) or you can build a\r\n[ParallelProgrammer](http://arduino.cc/en/Hacking/ParallelProgrammer) or an\r\n[ArduinoISP](http://arduino.cc/en/Tutorial/ArduinoISP).\r\nThe first three programmers should be connected to the ICSP pins (the 2 by 3 pin header) and make sure you plug\r\nit in the right way. The board must be powered by an external power supply or the USB port. In the case of _ArduinoISP_\r\nyou should consult the above link for further instructions on how to build and use.\r\n\r\nAfter you have connected the Arduino board and the programmer to your computer launch the Arduino IDE.\r\nNavigate to the __Tools__ > __Board__ menu and select ```Arduino Duemilanove/Uno(ATmega328) w/ Ariadne Bootloader```\r\nif you have an Arduino Duemilanove or Uno with an Ethernet Shield or ```Arduino Ethernet w/ Ariadne Bootloader```\r\nfor Arduino Ethernet. Then go to __Tools__ > __Programmer__ and select the programmer you are using.\r\nIn case you are using _ArduinoISP_, make sure that the selected port in the __Tools__ > __Serial Port__ menu refers to\r\nthe _ArduinoISP_ and not the board that you want to burn the bootloader on. Now, just launch the __Tools__ > __Burn Bootloader__\r\ncommand and wait for about 15 seconds for the operation to complete.\r\n\r\n\r\nSerial Flashing\r\n---------------\r\nAriadne bootloader supports flashing through serial like any other regular bootloader. This way of uploading is\r\nbuilt upon the very good *Optiboot* bootloader so it should be pretty straight forward to use. Just plug in the USB\r\ncable and select the serial port and the appropriate board from the __Tools__ > __Board__ menu. After that you must press the\r\nreset button and the indication LED on __pin 13__ or __pin 9__, in case of Arduino Ethernet, will start blinking rapidly.\r\nThis means that the bootloader is running and the Arduino is ready to be programmed. If there is a __valid__ program already\r\nflashed on the Arduino, you have to reprogram the device in the next __5 seconds__. If you don't, the bootloader will\r\ninitiate the program that is already in the Arduino. In case there is no program flashed or the program has been marked\r\nas __invalid__, the bootloader will never time out and you can reprogram it at any time.\r\n\r\nAfter a succesful flashing,\r\n\r\n* *Arduino Duemilanove* will automatically start the user's application.\r\n* *Arduino Uno* will do a reset cycle and start the program after the bootloader times out.\r\n\r\nThis happens because *Uno* has the autoreset feature that resets the board after a serial connection.\r\n\r\nDue to the fact that \"autoreset\" for remote tftp programming is implemented using a watchddog timer timeout, the bootloader\r\nwill do a full cycle after every reset, physical or software. For those who want *Adaboot No-Wait Mod*-like functionality,\r\nwe have been testing some options on how to circumvent these limitations, but they still need refinement.\r\n\r\n\r\nDefault Network Settings\r\n------------------------\r\nThe default built-in network settings of the bootloader are listed below.\r\n```\r\n* IP Address:  192.168.1.128\r\n* Subnet Mask: 255.255.255.0\r\n* Gateway:     192.168.1.1\r\n* MAC Address: 0xDE.0xAD.0xBE.0xEF.0xFE.0xED\r\n* TFTP Negotiation Port: 69\r\n* TFTP Data Port: 46969\r\n```\r\n\r\n___NOTE:___ The Arduino Ethernet that were sent as Indiegogo Perks were flashed with different network settings.\r\nTheir bootloader still defaults to the previous settings ___but___ the current values are on the accompaning leaflet.\r\n\r\n\r\nConfiguring Network Settings\r\n----------------------------\r\nThese can be changed using our __NetEEPROM__ library. The library is going to have it's own documentation on how it\r\ncan be used but for the purpose of changing and reading the network settings you can use the included examples. To load\r\nthem navigate to __File__ > __Examples__ > __NetEEPROM__ and select one of the examples. You can write the network\r\nsettings using the __WriteNetworkSettings__ sketch or print them to the serial using the __ReadNetworkSettings__.\r\n\r\nNote that the settings array in the __WriteNetworkSettings__ sketch hasn't got the settings in the usual order but\r\nrather in the order that __W5100__ reads them, so make sure you have put the correct values. If you set the network\r\nsettings you also have to set the TFTP data transfer port. The default is good enough but you may need to change it\r\nfor the reasons that are listed below in the\r\n[Configuring your Router for Remote Flashing](https://github.com/codebendercc/Ariadne-Bootloader#configuring-your-router-for-remote-flashing)\r\nsection. There is also documentation on how use these sketches in the form of comments so be sure to read them.\r\n\r\n\r\nTFTP Flashing\r\n-------------\r\nNow for the real reason we made this bootloader and why you should use it. First of all you can watch __Ariadne__ in\r\naction in this how-to video for remote flashing using TFTP [here](http://youtu.be/KCHqhV6xPMg). In the video you may\r\nnotice that the board is being reset by hand. In the next couple of weeks we are going to release the library that will\r\nallow remote resetting through a simple web server with some security measures. More on that as the library progresses.\r\n\r\n#####Converting your sketch to the right format\r\nUnlike serial flashing that uses __HEX__ files to flash the Arduino, the TFTP server implemented in the bootloader works\r\nwith binary files. This means that you have to manually convert your programs to the right format. To do that, first build\r\nyour sketch inside _Arduino IDE_ using the __Verify__ button. After that, without exiting the *Arduino IDE* you need\r\nto navigate to the temporary directory where your project was built. That is ```C:\\Users\\owner\\AppData\\Local\\Temp\\```\r\non *Windows*, ```/tmp``` on *Linux*. On *MacOS*  you'll need to go to Arduino's prefferences, and check the\r\n\"Show verbose output during compilation\" checkbox. After that, when you compile, you will see the path for the compiled .hex\r\nfile in the last line of the compilation output.. There you will find a folder named something like ```build2429295348207572157.tmp```.\r\nThat is where the Arduino temporary build files reside. Enter the directory and make sure that there is a ```.elf```\r\nor a ```.hex``` file with the same name as your sketch. That is the file you need to convert. To achieve that you have to\r\nrun one of the following commands in a terminal.\r\n\r\n* ```avr-objcopy -j .text -j .data -O binary [sketch].elf [sketch].bin```\r\n* ```avr-objcopy -I ihex [sketch].hex -O binary [sketch].bin```\r\n\r\nIn Windows and MacOS you can find the ```avr-objcopy``` program in your Arduino IDE installation folder under ```hardware/tools/avr/bin/```.\r\nOr,if you have scons installed, you can use the modified ```SConstruct``` script you can find in ```Ariadne-Bootloader/utilities```.\r\nThis being based on the *arscons* script, it can be used in two ways. If you used the previous process to generate the _HEX_\r\nfile you can just copy the ```SConstruct``` file inside the temporary *Arduino IDE* build directory (as mentioned above)\r\nand run ```scons``` in a terminal inside that directory.\r\n\r\nThe other way to use it is to copy the ```SConstruct``` script inside the sketch's directory and, as above, run\r\n```scons``` in a terminal inside that directory. This way you will build your project outside *Arduino IDE* creating\r\nthe ```.bin``` file in the process. Note that this way the sketch's folder will be polluted with Arduino's build files,\r\nmuch like the temporary directory *Arduino IDE* uses.\r\n\r\nFor testing purposes you can find a __blink__ sketch in binary form inside the ```Ariadne-Bootloader/utilities/tests/blink```\r\nfolder. The __fade__ sketch in the ```tests/fade``` folder will also give you a view of what a failed upload looks like.\r\nThis sketch fails because it is written in plain __C__ and not in __Arduino__. That way it lacks some \"signatures\" the\r\nbootloader uses to validate *Arduino* sketches. The third sketch in ```tests/led_display``` is an easter egg for which you\r\nneed to find out how we had our led matrices connected on *Arduino Uno*. Or we might release the schematics at some point.\r\nWho knows.\r\n\r\n\r\n#####Using a tftp client to upload the sketch\r\nNow that the binary is ready, you have to upload it. First you have to connect to your Arduino using any tftp client you\r\nmay have on your computer. All three major operating systems have their own clients that you can use through the command line.\r\nOn some __Linux__ distributions, like __Fedora/RedHat__, before you use ```tftp```, you should load the ```ip_conntrack_tftp```\r\nmodule or the tftp client won't be able to __ACK__ the packets sent. That is needed because TFTP is insecure and it is not\r\nenabled by default. Other distributions like __Arch__, don't need this step. To do that, open a terminal and run\r\n```\r\nmodprobe ip_conntrack_tftp\r\n```\r\nas __root__ using ```su``` or ```sudo```.\r\n\r\nAfter that open a terminal as a regular user and type ```tftp [ip] [port]```. For the default bootloader settings that would be:\r\n```\r\ntftp 192.168.1.128 69\r\n```\r\nIn this case it could just be ```tftp 192.168.1.128``` as __69__ is the default tftp port and the client would automatically\r\nconnect to it. For any other port you have to explicitly set it.\r\n\r\nNow you should have been greeted by the ```tftp> ``` prompt. First you have to enter this command:\r\n```\r\ntftp> mode octet\r\n```\r\nThis way you tell the __TFTP__ client to send binary data. This is absolutely needed as if your client is in netascii\r\nmode, uploading will fail. After this, it is advised to use the two following commands to make the process more informative\r\nso you can have a better view of what is happening, but they are not needed.\r\n```\r\ntftp> trace\r\ntftp> verbose\r\n```\r\nNow to actually upload the binary file all you have to do is __reset__ the board and in the next __5 seconds__ run\r\nthe following command.\r\n```\r\ntftp> put [sketch].bin\r\n```\r\nThe __5 second__ time frame is in case you already have a valid program uploaded on the Arduino. In case you don't have\r\na program loaded or it has been marked invalid, you don't have any time constraints.\r\n\r\nNow you should see your tftp client sending packets and the indication LED on __pin 13__ or __pin 9__ blinking in a random\r\nway, almost like having a hiccup. A correct output sample of the TFTP client uploading the *blink* sketch is below:\r\n```\r\ntftp> mode octet\r\n```\r\n```\r\ntftp> trace\r\nTrace mode on.\r\n```\r\n```\r\ntftp> verbose\r\nVerbose mode on.\r\n```\r\n```\r\ntftp> put blink.bin\r\nsent WRQ <file: blink.bin, mode: octet <>>\r\nreceived ACK <block: 0>\r\nsent DATA <block: 1, size: 512>\r\nreceived ACK <block: 1>\r\nsent DATA <block: 2, size: 512>\r\nreceived ACK <block: 2>\r\nsent DATA <block: 3, size: 512>\r\nreceived ACK <block: 3>\r\nsent DATA <block: 4, size: 512>\r\nreceived ACK <block: 4>\r\nsent DATA <block: 5, size: 42>\r\nreceived ACK <block: 5>\r\ntftp>\r\n```\r\nAfter a successful upload the bootloader will start the uploaded application instantly.\r\n\r\nIn case that for some reason the upload fails, first of all stop your TFTP client from sending any more packets. After that\r\nyou should wait for the upload process on the bootloader to timeout. That takes about __5 seconds__ too. For this period\r\nyou should witness the indication led doing some random blinking. After the timeout and since there is no valid program\r\nin the memory, the TFTP server should restart itself and wait for a new upload.\r\n\r\n\r\nConfiguring your Router for Remote Flashing\r\n-------------------------------------------\r\nIf you are having troubles flashing your Arduino at home from the road, you probably need to enable\r\n[port forwarding](http://en.wikipedia.org/wiki/Port_forwarding). You need to forward ports __69__ and __46969__ to your\r\nArduino in your router's configuration. In case you have changed the incoming data port from __46969__ to another port\r\ni.e. __50232__, you have to forward __50232__ port instead of __46969__. This is particularly useful when\r\nyou have more than one Arduinos, that you want to flash, behind your router. In addition to this you are going to have\r\nto translate an external port of your choice on the router to the internal port and ip of the Arduino in the local network.\r\nAn example is that you have 2 devices, one at *192.168.1.128* and one at *192.168.1.129*. They both listen to port\r\n__69__ for the initial connection. In this case you can translate external port __6969__(any random port will do) on\r\nyour router to *192.168.1.128*:__69__ and external port __6970__ to *192.168.1.129*:__69__ and specify these in the\r\ntftp client you are using.\r\n\r\nPort Forward has [excellent guides](http://portforward.com/english/routers/port_forwarding/) on how to enable port\r\nforwarding for a vast number of routers.\r\n\r\n\r\nCodebender\r\n-------------\r\nOne of the best ways and easiest ways to use this bootloader is along with [codebender.cc](http://codebender.cc).\r\nJust register, enter your Arduino's IP (external IP for those in corporate or home networks behind NAT) and flash.\r\n\r\n\r\nSupported Boards\r\n----------------\r\nRight now the __ATmega328__ processor and the __WizNet W5100__ ethernet controller are supported. That means\r\nthat your Arduino Uno, Arduino Duemilanove, Arduino Ethernet or any Arduino compatible board using these chipsets\r\ncan be burned with the Ariadne bootloader. If you have the know-how you can probably compile the bootloader for other\r\nprocessors but note that we haven't tested it. The following list will be updated over time.\r\n* [Arduino Ethernet](www.arduino.cc/en/Main/ArduinoBoardEthernet)\r\n* [Arduino Uno](http://www.arduino.cc/en/Main/ArduinoBoardUno)\r\n* [Arduino Duemilanove w/ ATmega328](http://www.arduino.cc/en/Main/ArduinoBoardDuemilanove)\r\n\r\nOther Tested Boards\r\n-------------------\r\nThese boards have been also tested and found to be working with Ariadne Bootloader. I don't have any of these so\r\na big ___thank you___ goes to the people that took their time to test them.\r\n* [ITead Studio IBoard](http://imall.iteadstudio.com/im120410001.html)\r\n* [Sparkfun Ethernet Pro](https://www.sparkfun.com/products/10536)\r\n\r\nRoadmap\r\n-------\r\nRight now the main focus for the first packaged release is bug fixing and improve existing functionality. That is why we\r\nencourage you to use the bootloader and report any bugs, misbehaviours or feature requests here on github. There is\r\nalso on going work to work on the Arduino Mega and support for Arduino Leonardo is planned after that. Support for\r\nother ethernet or wifi controllers is being discussed but after the bootloader has been stabilized.\r\n\r\n\r\nAcknoledgements\r\n---------------\r\n__Ariadne__ bootloader is built upon some great open source projects. First of all is the [TFTP-Bootloader](https://github.com/arduino/TFTP-Bootloader) from the\r\n*Arduino Team*. This is our base and we tried to stay on path with what they wanted to make. Serial flashing was made\r\npossible by [Optiboot](https://code.google.com/p/optiboot/) project's bootloader. Credit should also go to [mharizanov](https://github.com/mharizanov) for\r\ncommenting some of the initial *Arduino* code, making it easy for me to start and [follower](https://github.com/follower)\r\nwho's sketches served as a starting point for the included __NetEEPROM__ and __EthernetReset__ libraries.\r\n\r\n\r\nLicense\r\n-------\r\nThis is free software and it is released under the [GPLv2, GNU General Public License](https://www.gnu.org/licenses/gpl-2.0.html)\r\n","name":"Ariadne-bootloader"}